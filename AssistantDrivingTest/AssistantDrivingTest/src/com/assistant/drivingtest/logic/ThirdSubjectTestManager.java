package com.assistant.drivingtest.logic;import java.io.IOException;import java.security.PublicKey;import android.content.Context;import android.content.res.AssetFileDescriptor;import android.media.MediaPlayer;import android.media.MediaPlayer.OnCompletionListener;import android.media.MediaPlayer.OnErrorListener;import android.os.Handler;import android.os.HandlerThread;import android.os.Looper;import android.os.Message;import com.assistant.drivingtest.R;import com.assistant.drivingtest.domain.Deduction;import com.assistant.drivingtest.domain.ThirdTestItem;import com.assistant.drivingtest.logic.ThirdTestItemManager.Type;import com.assistant.drivingtest.logic.test.ChangeLineTestObject;import com.assistant.drivingtest.logic.test.DrivingStraightTestObject;import com.assistant.drivingtest.logic.test.OvertakeTestObject;import com.assistant.drivingtest.logic.test.SpeedTestObject;import com.assistant.drivingtest.logic.test.TestObject;import com.assistant.drivingtest.logic.test.TurnTestObject;import com.assistant.drivingtest.logic.test.UTurnTestObject;import com.assistant.drivingtest.utils.LogUtil;import com.assistant.drivingtest.utils.MapUtil;import com.baidu.mapapi.map.LocationData;public class ThirdSubjectTestManager {	private static final String TAG = "ThirdSubjectTestManager";	private static final double ZERO_AZIMUTH = 360;	private static final double INVALID = 1000000;	private static final int CALCULATE_SPEED_INTERVAL = 2 * 1000;	private static final int TEST_FAIL_DELAY = 0;	private static final int PLAY_VOICE = 1;	private static final int SUCCESS = 2;	private static final int CALCULATE_SEPPD = 3;	private Context mContext;	private MediaPlayer mPlayer;	private ThirdTestItem mTestItem;	private double mAzimuth = INVALID;	private double mAzimuthChange;	private LocationData mLocationData;	private ITestItemListener mItemListener;	private double mIsZeroAzimuth;	private ThreadHandler mHandler;	private ThreadHandler mThreadHandler;	private boolean mStart;	private Object mClock = new Object();	private TestObject mTestObject;	private boolean mIsFinish;	private int mResult;	public ThirdSubjectTestManager(Context context) {		mContext = context;		mHandler = new ThreadHandler();		HandlerThread thread = new HandlerThread("ThirdSubjectTestManager");		thread.start();		mThreadHandler = new ThreadHandler(thread.getLooper());	}	public void setTestItem(ThirdTestItem testItem, boolean isManual) {		synchronized (mClock) {			if (null == testItem) {				return;			}			mTestItem = testItem;			mThreadHandler.sendMessage(mThreadHandler.obtainMessage(PLAY_VOICE,					mTestItem.voice));			switch (mTestItem.type) {			case ThirdTestItemManager.Type.TURN_LEFT:			case ThirdTestItemManager.Type.TURN_RIGHT:				mTestObject = new TurnTestObject(mContext, this, mTestItem,						true, isManual);				break;			case ThirdTestItemManager.Type.INTERSECTION_STRAIGHT:				// 路口直行不需要判断角度				mTestObject = new TurnTestObject(mContext, this, mTestItem,						false, isManual);				break;			case ThirdTestItemManager.Type.U_TURN:				mTestObject = new UTurnTestObject(mContext, this, mTestItem,						isManual);				break;			case ThirdTestItemManager.Type.CHANGE_LINE:				mTestObject = new ChangeLineTestObject(mContext, this,						mTestItem, isManual);				break;			case ThirdTestItemManager.Type.DRIVING_STRAIGHT:				mTestObject = new DrivingStraightTestObject(mContext, this,						mTestItem, isManual);				break;			case ThirdTestItemManager.Type.SCHOOL:			case ThirdTestItemManager.Type.BUS_STATION:			case ThirdTestItemManager.Type.CROSSWALK:				mTestObject = new SpeedTestObject(mContext, this, mTestItem,						isManual);				break;			case ThirdTestItemManager.Type.OVERTAKE:				mTestObject = new OvertakeTestObject(mContext, this, mTestItem,						isManual);				break;			default:				break;			}		}	}	public void setLocationData(LocationData locationData) {		mLocationData = locationData;		if (null != locationData && mStart && null != mTestObject) {			mTestObject.setLocation(locationData);		}	}	public void setSpeed(double speed) {		if (null != mTestItem && mStart && null != mTestObject) {			mTestObject.setSpeed(speed);		}	}	public void setAzimuth(double azimuth) {		if (null == mTestItem) {			return;		}		synchronized (mClock) {			if (mAzimuth != INVALID) {				double change = azimuth - mAzimuth;				if (change > 300) {					mIsZeroAzimuth += -ZERO_AZIMUTH;				} else if (change < -300) {					mIsZeroAzimuth += ZERO_AZIMUTH;				}			}			mAzimuth = azimuth;			mAzimuthChange = mAzimuth - mTestItem.azimuth + mIsZeroAzimuth;			if (null != mItemListener) {				mItemListener.setAngle(mAzimuthChange);			}			if (!mStart || null == mTestObject) {				return;			}			mTestObject.setAzimuth(mAzimuthChange);		}	}	public void testSuccess() {		LogUtil.d(TAG, "testSuccess:" + mTestItem);		synchronized (mClock) {			resetTestItem();			if (null != mItemListener) {				mItemListener.onItemComplete();			}		}	}	public void testFail(Deduction deduction) {		synchronized (mClock) {			if (null != mItemListener && null != mContext) {				mResult = mResult + deduction.scores;				mItemListener.testFail(deduction);			}			resetTestItem();		}	}	public void addDeduction(Deduction deduction) {		if (null != mItemListener) {			mResult = mResult + deduction.scores;			mItemListener.addDeductionMessage(deduction);		}	}	public int getResult() {		return mResult;	}	public void setFinish(boolean finish) {		mIsFinish = finish;	}	public void play(String path) {		mThreadHandler.sendMessage(mThreadHandler.obtainMessage(PLAY_VOICE,				path));	}	private void resetTestItem() {		mTestItem = null;		mAzimuthChange = 0;		mIsZeroAzimuth = 0;		mTestObject = null;		mStart = false;		if (null != mHandler) {			mHandler.removeMessages(TEST_FAIL_DELAY);		}	}	public void setListener(ITestItemListener listener) {		mItemListener = listener;	}	private void calculateSpeed(LocationData locationData) {		if (null == locationData || null == mLocationData) {			return;		}		int distance = MapUtil.getDistanceInt(mLocationData.latitude,				mLocationData.longitude, locationData.latitude,				locationData.longitude);		float speed = (float) distance / 2;		LogUtil.d(TAG, "distance:" + distance + ", speed:" + speed);		if (null != mItemListener) {			mItemListener					.setSpeed(speed, distance + "  " + mLocationData.speed);		}	}	private void playVoice(String voice) {		if (null == mPlayer) {			mPlayer = new MediaPlayer();			mPlayer.setOnCompletionListener(new OnCompletionListener() {				@Override				public void onCompletion(MediaPlayer mp) {					LogUtil.d(TAG, "onCompletion mTestObject:" + mTestObject);					if (mIsFinish) {						return;					} else if (null == mTestObject) {						mHandler.sendEmptyMessage(SUCCESS);					} else {						mStart = true;						// mHandler.sendEmptyMessageDelayed(TEST_FAIL_DELAY,						// 5 * 1000);					}				}			});			mPlayer.setOnErrorListener(new OnErrorListener() {				@Override				public boolean onError(MediaPlayer mp, int what, int extra) {					return false;				}			});		} else {			mPlayer.reset();		}		try {			AssetFileDescriptor fileDescriptor = mContext.getAssets().openFd(					voice);			mPlayer.setDataSource(fileDescriptor.getFileDescriptor(),					fileDescriptor.getStartOffset(), fileDescriptor.getLength());			mPlayer.prepare();			mPlayer.start();		} catch (IllegalArgumentException e) {			e.printStackTrace();		} catch (IllegalStateException e) {			e.printStackTrace();		} catch (IOException e) {			e.printStackTrace();		}	}	public void onDestroy() {		if (null != mPlayer) {			mPlayer.release();			mPlayer = null;		}		if (null != mHandler) {			mHandler.removeMessages(TEST_FAIL_DELAY);			mHandler.removeMessages(CALCULATE_SEPPD);			mHandler = null;		}		if (null != mThreadHandler) {			mThreadHandler.removeMessages(TEST_FAIL_DELAY);			mThreadHandler.getLooper().quit();			mThreadHandler = null;		}		mContext = null;		mItemListener = null;	}	public interface ITestItemListener {		void onItemComplete();		void setAngle(double angle);		void setSpeed(float speed, String distance);		void testFail(Deduction deduction);		void addDeductionMessage(Deduction deduction);	}	private class ThreadHandler extends Handler {		ThreadHandler() {		}		ThreadHandler(Looper looper) {			super(looper);		}		@Override		public void handleMessage(Message msg) {			super.handleMessage(msg);			switch (msg.what) {			case TEST_FAIL_DELAY:				Deduction deduction = new Deduction();				deduction.name = mTestItem.name;				deduction.reason = mContext						.getString(R.string.deduction_message);				deduction.scores = -100;				testFail(deduction);				break;			case PLAY_VOICE:				playVoice(String.valueOf(msg.obj));				break;			case SUCCESS:				testSuccess();				break;			case CALCULATE_SEPPD:				if (null != msg.obj) {					calculateSpeed((LocationData) msg.obj);				}				sendMessageDelayed(						mHandler.obtainMessage(CALCULATE_SEPPD, mLocationData),						CALCULATE_SPEED_INTERVAL);				break;			default:				break;			}		}	}}